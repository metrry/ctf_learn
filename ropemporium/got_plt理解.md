# GOT、PLT理解

## 简介

> ​	虽然看了多次GOT、PLT的资料，也收藏了许多相关介绍，但实际上还是一知半解，俗话说“好记性不如烂笔头”，更何况现在这个年纪基本是看完就忘，不过也说明自己看的不深，理解能力不足，因此有了这篇文章，算是强化一下吧。

​	在理解GOT、PLT之前先引入`静态链接`和`动态链接`两个概念，相信有接触过C/C++语言的童鞋都应该知道这两个的区别，在这里还是要赘述一下。

​	***静态链接***

​	静态链接的可执行程序可以说是完备的，运行时所需要的代码都在一个可执行文件，不需要依赖其他外部的库，也就是说它用到的代码可以在代码编译的时候就确定下来。

​	***动态链接***

​	动态链接的程序则不需要将所有函数和代码集中在一个文件中，它依赖第三方库或者系统库，例如libc库。

## 重定位

​	假设这么一个场景：编写了一个程序使用`printf`函数打印一些数据，我们知道`printf`函数在系统C库中已经实现了，要使用它就需要知道它的地址并进行调用，也就是说在编译的时候要确定下来`printf`的地址，但是这样的话就会带来其他问题：

 	1. 每次C库发生变化，其对应的函数地址就会发生变化，因此需要重新编译该程序；
 	2. 采用硬编码地址的方法也让ALSR方法失去了价值。

用代码说话，参考如下代码：

```c
int main(void)
{
    printf("ok, let's go");
    return 0;
}
```

代码只有一个printf函数，以32位平台为主进行分析。

> gcc -Wall -g -o test.o -c test.c -m32  
> gcc -o test test.o -m32

编译、链接后test程序对应的汇编代码应该是下面这个样子：

```assembly
   0x0804840d <+0>:     push   ebp
   0x0804840e <+1>:     mov    ebp,esp
   0x08048410 <+3>:     and    esp,0xfffffff0
   0x08048413 <+6>:     sub    esp,0x10
   0x08048416 <+9>:     mov    DWORD PTR [esp],0x80484c4
   0x0804841d <+16>:    call   [<printf的地址>]
   0x08048422 <+21>:    mov    eax,0x0
   0x08048427 <+26>:    leave  
   0x08048428 <+27>:    ret    
```

​	由于使用的是系统C库中的函数，而C库加载的地址在编译、链接时是无法确定的，所以这里printf的地址也是无法确定的，只有程序跑起来后才能确定。但问题是程序跑起来了，也找到了printf函数的实际地址，代码里[prinf]的地址怎么填充进去呢？我们知道代码段是不能动态修改的，因此没法直接修改其地址，也就就说printf真正的地址只能写到数据段而不能写回到代码段。

​	这时引入一种叫“重定位”的方法来解决这个问题，它分为`链接重定位`很`运行重定位`。后面写到的重定位默认指运行重定位。

​	前面我们讨论到只能将printf重定位到数据段，那么编译时生成的call指令是如何使用这个重定位的数据段的内容呢？

答案是：

> 使用连接器，连接器生成一段额外的代码片段，通过代码片段来获取printf函数的地址，并完成调用。

查看ELF文件时可以看到有几个段是重定向时用到的。

**.got** 全局偏移表（Global Offset Table ），链接器会填充外部符号的实际偏移地址。初始时got表中指向了plt表中对应项的地址，当链接器成功找到其实际偏移帝之后会进行实际地址进行填充。下次再执行到

**.plt**程序链接表（Procedure Linkage Table ）将位置无关的符号转移到绝对地址。当一个外部符号被调用时，plt会引用got中的symbol对应的绝对地址，然后调转执行。

GOT 位于 `.got.plt` section 中，而 PLT 位于 `.plt` section中。